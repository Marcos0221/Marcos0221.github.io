<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Marcos的个人小站，技术，心得的展示地方"><title>《嵌入式系统中的神奇魔法——IAP详解》 | Marcos的独立博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《嵌入式系统中的神奇魔法——IAP详解》</h1><a id="logo" href="/.">Marcos的独立博客</a><p class="description">分享技术，享受生活</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《嵌入式系统中的神奇魔法——IAP详解》</h1><div class="post-meta">2024-12-12<span> | </span><span class="category"><a href="/categories/STM32/">STM32</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.1k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 7</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><blockquote>
<p>大家好，我是一名专注于嵌入式领域的知识分享者，在嵌入式系统开发与研究的道路上已经走过了不少年头，积累了丰富的实践经验与理论知识。在当今快速发展的科技时代，嵌入式设备无处不在，从我们日常使用的智能手机、智能家居设备，到工业控制中的复杂系统，乃至汽车的电子控制单元等。而这些设备的软件功能需要不断地优化、升级以适应新的需求、修复潜在漏洞以及提升性能。</p>
<p>在这样的背景下，IAP（In Application Programming，在应用中编程）技术应运而生并扮演着极为关键的角色。它就像是一把神奇的钥匙，开启了嵌入式设备固件更新的便捷之门，无需繁琐的拆卸或专业设备辅助，就能让设备在运行过程中通过预留的通信接口轻松完成固件的更新升级。这种技术极大地提高了设备的可维护性和灵活性，特别是在智能家居、汽车电子、物联网设备等需要频繁更新固件的场景中，IAP 已然成为了保障设备持续稳定高效运行以及功能不断拓展的核心技术力量，让嵌入式设备能够与时俱进，更好地服务于我们的生活与生产。接下来，就让我们深入探究 IAP 的奥秘。</p>
</blockquote>
<h1 id="什么是-IAP"><a href="#什么是-IAP" class="headerlink" title="什么是 IAP"></a>什么是 IAP</h1><p>IAP（In Application Programming，在应用中编程）是一种嵌入式系统中常用的固件更新技术。它允许用户程序在运行过程中，通过预留的通信接口对设备的固件进行更新升级。这种技术极大地提高了设备的可维护性和灵活性，特别是在智能家居、汽车电子、物联网设备等需要频繁更新固件的场景中尤为重要。</p>
<h1 id="IAP-的工作原理"><a href="#IAP-的工作原理" class="headerlink" title="IAP 的工作原理"></a>IAP 的工作原理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul>
<li>IAP 技术通过将 Flash 存储器划分为两个主要区域来实现固件更新。</li>
<li>Bootloader 区域：包含引导加载程序，负责初始化硬件、设置内存映射，并在需要时加载和更新用户应用程序（User Application）。Bootloader 出厂后通常固定不变，只有在特定条件下（如接收到升级指令）才执行更新操作。</li>
<li>User Application 区域：存放用户的应用程序代码，这部分代码在需要时可以通过 Bootloader 进行更新。</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol>
<li>设备启动：设备上电后，首先执行 Bootloader 程序。Bootloader 检查是否有升级指令或新固件数据待处理。</li>
<li>固件更新检查：如果检测到有升级需求，Bootloader 通过预留的通信接口接收新固件数据，并将其写入 Flash 的 User Application 区域。</li>
<li>固件验证：写入完成后，Bootloader 进行固件验证，确保数据完整性和正确性。</li>
<li>跳转执行：验证通过后，Bootloader 跳转到 User Application 区域的新固件执行。</li>
</ol>
<h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><ul>
<li>Flash 存储器管理：包括擦除扇区、写入数据和校验数据等操作，这些操作通常以块或扇区为单位进行。</li>
<li>数据传输与接收：通过串口、USB 等通信接口接收新固件数据，并存储在 RAM 中，待验证无误后写入 Flash。</li>
<li>安全性与完整性校验：通过加密、签名和校验和等技术确保数据在传输和存储过程中的安全性和完整性。</li>
</ul>
<h1 id="在-STM32-上实现-IAP-程序"><a href="#在-STM32-上实现-IAP-程序" class="headerlink" title="在 STM32 上实现 IAP 程序"></a>在 STM32 上实现 IAP 程序</h1><h2 id="STM32-启动流程"><a href="#STM32-启动流程" class="headerlink" title="STM32 启动流程"></a>STM32 启动流程</h2><p>STM32 在上电或复位后，首先会从内部的 Flash 存储器的起始地址（一般为 0x08000000）读取堆栈指针<strong>SP</strong>的值，然后<strong>加载复位向量</strong>，即<strong>跳转到复位处理函数</strong>。复位处理函数会进行一系列的系统初始化操作，包括时钟系统初始化、中断向量表的设置等。完成这些初始化后，会<strong>跳转到用户代码的入口点</strong>（通常是 main 函数）开始执行用户应用程序。在 IAP 实现中，了解这个启动流程对于正确划分 Bootloader 和 User Application 区域以及实现跳转执行等操作至关重要。</p>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><p>以 STM32F103C8T6 为例，该单片机内置 64KB Flash 和 20KB SRAM。在进行 IAP 设计时，需要合理划分 Bootloader 和 User Application 的区域大小；这里我把 Flash 平均分为两部分，Bootloader 占 32KB，User Application 也占 32KB。</p>
<h2 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h2><h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><ol>
<li>初始化硬件：对串口、时钟等相关硬件进行初始化设置，确保能正常进行数据通信与后续操作。例如，设置串口的波特率等参数，使能串口接收中断以便及时接收新固件数据。</li>
<li>检查升级指令：持续监听特定的升级指令，如通过串口接收特定的命令字符或数据包头信息来判断是否需要进行固件升级。</li>
<li>接收新固件数据：当检测到升级指令后，通过串口等通信接口按约定的协议接收新固件数据，并将其存储在 RAM 中。<strong>需要注意</strong>数据接收的完整性和顺序性，可采用数据帧编号、校验和等方式来保证。</li>
<li>写入 Flash：在接收到完整的固件数据并验证无误后，将数据从 RAM 写入到 Flash 的 User Application 区域。写入时要严格按照 Flash 的编程规范操作，先擦除对应扇区（因为 Flash 只能写 0 不能直接写 1，写入前需擦除为 1），再将数据逐字节或逐字写入。同时要处理好 Flash 写入的时序和编程电压等要求，防止写入错误。</li>
<li>跳转至应用程序（User Application）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> APP_FLASH_ADDRESS (0x8008000)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="title function_">void</span> <span class="params">(*pFunction)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">pFunction Jump_To_Application;</span><br><span class="line"><span class="type">uint32_t</span> JumpAddress;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">JumpToApp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 检查是否为有效的栈地址，然后跳转到用户应用程序 */</span></span><br><span class="line">    <span class="keyword">if</span> (((*(__IO <span class="type">uint32_t</span>*)APP_FLASH_ADDRESS) &amp; <span class="number">0x2FFE0000</span> ) == <span class="number">0x20000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __disable_irq();</span><br><span class="line">       <span class="comment">/* 跳转到用户应用程序 */</span></span><br><span class="line">       JumpAddress = *(__IO <span class="type">uint32_t</span>*) (APP_FLASH_ADDRESS + <span class="number">4</span>);</span><br><span class="line">       Jump_To_Application = (pFunction) JumpAddress;</span><br><span class="line">       <span class="comment">/* 初始化用户应用程序的栈指针 */</span></span><br><span class="line">       __set_MSP(*(__IO <span class="type">uint32_t</span>*) APP_FLASH_ADDRESS);</span><br><span class="line">       Jump_To_Application();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="User-Application"><a href="#User-Application" class="headerlink" title="User Application"></a>User Application</h3><ol>
<li>配置中断向量表偏移：由于加入了 Bootloader 程序，User Application 的中断向量表位置发生了偏移。需要通过相应的函数来设置中断向量表的偏移量，在 STM32 中可以使用 <code>NVIC_SetVectorTable()</code> 函数。示例代码如下 ：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_BASAE 0x08000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECT_TAB_OFFEST 0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 修改中断向量</span></span><br><span class="line">    SCB-&gt;VTOR = FLASH_BASAE | VECT_TAB_OFFEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<!-- 1. 功能实现：专注于实现设备的具体业务功能，如传感器数据采集、数据处理与传输等。
触发机制：预留触发 Bootloader 进行固件升级的机制，比如通过特定的串口命令、按键组合或者网络指令等。在接收到升级触发信号后，要能正确地跳转到 Bootloader 程序入口执行升级流程。同时，在正常运行过程中要避免误触发升级机制。
2. Flash 分区：在链接脚本中明确划分 Bootloader 和 User Application 的 Flash 区域大小。确保两个区域不重叠，并预留足够的空间用于固件更新。例如，可将 Bootloader 区域设置为较小的固定大小，如 32KB，将剩余的 Flash 空间分配给 User Application，并考虑到未来固件升级可能增加的大小预留一定的余量。 -->

<h3 id="固件升级流程"><a href="#固件升级流程" class="headerlink" title="固件升级流程"></a>固件升级流程</h3><ol>
<li>设备上电后，Bootloader 首先检查是否有升级指令。</li>
<li>如果有，则通过串口等通信接口接收新固件数据。接收过程中要进行数据校验，如计算校验和并与发送端的校验和对比，确保数据准确无误。</li>
<li>接收完成后，进行固件验证，可采用加密算法验证数据的完整性和合法性，防止恶意固件更新。</li>
<li>验证无误后，跳转到新固件执行。在跳转前要确保系统处于稳定状态，关闭不必要的中断和外设，然后按照 STM32 的跳转指令规范准确地跳转到新固件的入口地址。</li>
</ol>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>这次关于嵌入式系统中 IAP 的分享就到此结束啦！希望通过这篇文章，大家对 IAP 有了较为全面且深入的认识。从它的基本概念到工作原理，从应用案例的展示到在 STM32 上的详细实现步骤，每一个环节都如同拼图的碎片，拼凑出了 IAP 技术的完整画卷。在实际应用中，大家可以依据自身项目需求，灵活运用 IAP 技术，为嵌入式设备打造更强大、更具适应性的固件更新方案。如果在实践过程中遇到任何问题，欢迎随时回顾本文或者查阅更多相关资料深入探索。感谢大家的阅读与关注，期待下一次与大家继续在嵌入式知识的海洋里畅游，共同挖掘更多有趣且实用的技术奥秘！</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STM32/" rel="tag">STM32</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/12/12/b465bfd7c1b3/">想法</a><a class="next" href="/2024/12/12/6a7c5a8b24c7/">安卓开发踩坑记录</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="Über"><img class="nofancybox" src="/img/favico.png"/></a><p>To be a better man.</p><a class="info-icon" href="mailto:3091977221@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/marcos0221" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/STM32/">STM32</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">C语言</a> <a href="/tags/Termux/" style="font-size: 15px;">Termux</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/STM32/" style="font-size: 15px;">STM32</a> <a href="/tags/Nvim/" style="font-size: 15px;">Nvim</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a> <a href="/tags/%E5%BF%83%E6%83%85/" style="font-size: 15px;">心情</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 15px;">嵌入式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2055/01/05/112c73da27dc/">LinuxC网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/06/2434ab2b60f4/">Hexo代码框样式美化</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/12/b465bfd7c1b3/">想法</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/12/168241c6184c/">《嵌入式系统中的神奇魔法——IAP详解》</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/12/6a7c5a8b24c7/">安卓开发踩坑记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/19/54ca602dd337/">STM定时器编码器模式学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/26/3fd3faff9761/">STM32代码配置模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/13/a496743ab17d/">C语言注释规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/02/e21da8549493/">Git | commit 规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/25/7e590ba7e0f4/">Termux配置NeoVim保姆级教程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Marcos的独立博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>