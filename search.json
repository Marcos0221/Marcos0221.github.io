[{"title":"问题记录","path":"/2025/03/14/1ec7f9a0c5ce/","content":"题目描述 需求分析📙问题大全和解决方法ADC采样率怎么确定根据奈奎斯特定理得出，ADC采样率至少要是采集目标频率的2倍，一般建议采样频率设置为5~10倍或更高。 ADC采样率是越高越好吗当然不是，不过高采样率不会影响低频信号的准确度（我当时采集1Hz信号时一直不对，怀疑过这里，不过经过验证，跟高采样率无关）。 ADC的谐波怎么提取将FFT处理后的结果进行排序，除去最大值基波，然后其他的就是谐波。 怎么根据谐波来确定波形的类型根据谐波判断 正弦波: 各次谐波幅度几乎为零。 方波：基波幅度最大，奇次谐波幅度按$\\frac{1}{2}$（n为谐波次数）规律衰减，如三次谐波幅度约为基波的$\\frac{1}{3}$，五次谐波约为$\\frac{1}{5}$。 三角波：基波幅度较大，奇次谐波幅度按$\\frac{1}{n^2}$规律衰减，所以三次谐波幅度约为基波的$\\frac{1}{9}$，五次谐波约为$\\frac{1}{25}$。 根据RMS算法来判断 正弦波：纯正弦波信号 RMS 值与峰值关系为$V_{RMS}\\frac{V_{peak}}{\\sqrt{2}}$ 。测量信号 RMS 值，若与按此公式依峰值算出的结果相近，且频谱分析谐波含量极低，可判断为正弦波。 方波：方波 RMS 值等于幅值，即$V_{RMS}A$。测量信号幅值与 RMS 值，若二者相等，且频谱呈现基波幅度最大、奇次谐波幅度按$\\frac{1}{n}$n 为谐波次数）规律衰减，可判断为方波。 三角波：三角波 RMS 值与峰值关系为$V_{RMS}\\frac{V_{peak}}{\\sqrt{3}}$ 。测量信号 RMS 值，若符合此关系，且频谱中基波幅度较大、奇次谐波幅度按规律衰减，可判断为三角波。 高采样率采集低频信号误差大在尝试用1Mhz的采样率采集50Hz信号时，偏差超级大，是ADC没有采集到完全的波形嘛？并不是，是高采样率加重了计算的误差，所以要采集50Hz~50Khz的信号的话应该对信号进行分档，这样的话会减少计算的误差。 低频信号采样转换速度慢在采集1~10Hz的信号时，采样和转换的速度很慢，曾让我误以为是定时器配置错了，后面一思考，应该是采样点数和采样频率影响的。这里我降低了采样点数，由1024-128，速度一下就快起来了，这里由可以根据频率来确定采样点数了。 挡位分配 频率区间 ADC采样率 ADC采集点数 分频系数 低速挡 50Hz~500Hz 2500Hz 2048 400 中速档 500Hz~5Khz 25Khz 4096 40 高速档 5Khz~50Khz 250Khz 4096 4","categories":["经验闲谈"]},{"title":"算法与数据结构之—顺序表","path":"/2025/02/08/c76f1a741c41/","content":"顺序表是随机存取的存储结构。 需要实现的方法 销毁顺序表 检查顺序表容量是否溢出 顺序表尾插 顺序表尾删 顺序表头插 顺序表头删 打印顺序表 在顺序表查找指定值返回其下标 在顺序表指定下标插入值 在顺序表删除指定下标的值 查看有效位数 修改指定下标的值 参考代码 #include assert.h#include stdio.h#include stdlib.htypedef int E;struct List E *arr;\tint length;\tint size;;typedef struct List *ArrayList;// 初始化顺序表int initList(ArrayList list) list-length = 10;\tlist-arr = malloc(sizeof(E) * 10);\tif (list-arr == NULL) printf(内存空间申请失败); return -1; list-size = 0;\treturn 0;// 在顺序表指定位置处插入元素void insertList(ArrayList list, int insertIndex, E element) for (int i = list-size; i 0; i--) list-arr[i] = list-arr[i - 1]; list-arr[insertIndex - 1] = element;\tlist-size++;// 在顺序表指定位置处删除元素void deleteListToIndex(ArrayList list, int deleteIndex) for (int i = deleteIndex; i list-size; i++) list-arr[i - 1] = list-arr[i]; list-size--;// 释放顺序表void destoryList(ArrayList list) assert(list != NULL);\tfree(list-arr);\tlist-length = 0;\tlist-size = 0;// 获取指定位置的元素E getIndexListElement(ArrayList list, int index) return list-arr[index]; // 顺序表尾部插入元素void insertListToEnd(ArrayList list, E element) list-arr[list-size] = element;\tlist-size++;// 顺序表尾部删除元素void deleteListToEnd(ArrayList list) list-arr[list-size] = 0;\tlist-size--;// 顺序表头部插入元素void insertListToStart(ArrayList list, E element) for (int i = list-size; i 0; i--) list-arr[i] = list-arr[i - 1]; list-arr[0] = element;\tlist-size++;// 顺序表头部删除元素void deleteListToStart(ArrayList list) for (int i = 0; i list-size; i++) list-arr[i] = list-arr[i + 1]; list-size--;// 顺序表查找指定值返回下标int findListValue(ArrayList list, E element) for (int i = 0; i list-size; i++) if (list-arr[i] == element) return i; return -1;// 修改指定下标数据int changeIndexElement(ArrayList list, int index, E element) if (index list-size) list-arr[index] = element; return 0; return -1;void printArrayList(ArrayList list) for (int i = 0; i list-size; i++) printf(%d , list-arr[i]);\tint main() struct List list;\tif (initList(list) != 0) printf(初始化顺序表失败 ); insertList(list, 1, 666);\tinsertList(list, 1, 777);\tinsertListToStart(list, 555);\tchangeIndexElement(list, 2, 888);\tprintf(777所在的下标为: %d , findListValue(list, 777));\tprintf(顺序表的size: %d , list.size);\tprintArrayList(list);\treturn 0;","tags":["C语言","算法"]},{"title":"算法与数据结构","path":"/2025/02/08/08c181fe7503/","content":"衡量算法好坏的指标 时间复杂度T(n)：算法程序在执行时消耗的时间长度，一般与输入数据的规模n有关。 空间复杂度S(n)：算法程序在执行时占用的存储单元长度，同样与数据的输入规模n有关，大部分情况下，我们都是采取空间换时间的算法。","tags":["算法"]},{"title":"我的20岁","path":"/2025/01/24/7c659f2dc35c/","content":"今天不再是普普通通的一天了，因为我也来到了2开头的年纪，这是以2开头的年纪度过的第一天，好像也挺普通的。 今天也是一觉睡到大中午，一醒来就收到了妈妈和姑姑的信息，姑姑对我真的太好了，今年是收到压岁钱最多的一年，但是大部分都是姑姑给的，而且今天姑姑又给我发红包了，我铭记于心。随便吃点东西就计划着晚上要不要出去吃点什么，我的物欲很低，不太想出门，或许会点个外卖吧。 选择困难症犯了，真实难以选择。 好吧，带妹妹出去吃了顿烤肉就回来了，100个币去抓娃娃，就抓到两个，哈哈。 好普通，我居然连一张照片都没有拍，草草的结束了我的20岁生日。","tags":["随笔","心情"]},{"title":"安卓开发踩坑记录","path":"/2025/01/18/618e2e50bf70/","content":"通过包名启动app /** * 通过包名启动应用 * @param context * @param packageName 欲启动应用包名 */ fun openApp(context: Context, packageName:String) val intent = context.packageManager.getLaunchIntentForPackage(packageName) intent?.flags = Intent.FLAG_ACTIVITY_NEW_TASK ; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED context.startActivity(intent) 试过了吗，是不是报错了，而且还是这个 java.lang.NullPointerException: Attempt to invoke virtual method boolean android.content.Intent.migrateExtraStreamToClipData(android.content.Context) on a null object reference Android11及以上，谷歌权限收紧，调用getLaunchIntentForPackage时候，内部实现无法根据包名查询到对应activity名称了，所以获取的intent是null，也就是拉不起来了，声明后就可以查看了。 所以我们需要在 AndroidManifest.xml 中配置声明包可见性 queries\tpackage android:name=com.marcos.xxx//queries 然后再次尝试运行，是不是可以正常打开应用啦 如果觉得这样很麻烦的话，那么可以这样 uses-permission android:name=android.permission.QUERY_ALL_PACKAGES tools:ignore=QueryAllPackagesPermission/ 这样就不用重复配置了 参考文章：Android 11以上如何通过包名拉起App 状态栏顶起布局// 在xml布局文件中的根布局添加，布局就不会被顶起了android:fitsSystemWindows=true RecyclerView Item布局宽高无效问题原因及解决方法这种加载方式Item宽高失效。 LayoutInflater.from(parent.getContext()).inflate(R.layout.inflate_test_item,null) 这种方式加载布局item不会出现宽高失效。 LayoutInflater.from(parent.getContext()).inflate(R.layout.inflate_test_item,parent,false)","categories":["Android"]},{"title":"《嵌入式系统中的神奇魔法——IAP详解》","path":"/2024/12/12/168241c6184c/","content":"大家好，我是一名专注于嵌入式领域的知识分享者，在嵌入式系统开发与研究的道路上已经走过了不少年头，积累了丰富的实践经验与理论知识。在当今快速发展的科技时代，嵌入式设备无处不在，从我们日常使用的智能手机、智能家居设备，到工业控制中的复杂系统，乃至汽车的电子控制单元等。而这些设备的软件功能需要不断地优化、升级以适应新的需求、修复潜在漏洞以及提升性能。 在这样的背景下，IAP（In Application Programming，在应用中编程）技术应运而生并扮演着极为关键的角色。它就像是一把神奇的钥匙，开启了嵌入式设备固件更新的便捷之门，无需繁琐的拆卸或专业设备辅助，就能让设备在运行过程中通过预留的通信接口轻松完成固件的更新升级。这种技术极大地提高了设备的可维护性和灵活性，特别是在智能家居、汽车电子、物联网设备等需要频繁更新固件的场景中，IAP 已然成为了保障设备持续稳定高效运行以及功能不断拓展的核心技术力量，让嵌入式设备能够与时俱进，更好地服务于我们的生活与生产。接下来，就让我们深入探究 IAP 的奥秘。 什么是 IAPIAP（In Application Programming，在应用中编程）是一种嵌入式系统中常用的固件更新技术。它允许用户程序在运行过程中，通过预留的通信接口对设备的固件进行更新升级。这种技术极大地提高了设备的可维护性和灵活性，特别是在智能家居、汽车电子、物联网设备等需要频繁更新固件的场景中尤为重要。 IAP 的工作原理基本原理 IAP 技术通过将 Flash 存储器划分为两个主要区域来实现固件更新。 Bootloader 区域：包含引导加载程序，负责初始化硬件、设置内存映射，并在需要时加载和更新用户应用程序（User Application）。Bootloader 出厂后通常固定不变，只有在特定条件下（如接收到升级指令）才执行更新操作。 User Application 区域：存放用户的应用程序代码，这部分代码在需要时可以通过 Bootloader 进行更新。 工作流程 设备启动：设备上电后，首先执行 Bootloader 程序。Bootloader 检查是否有升级指令或新固件数据待处理。 固件更新检查：如果检测到有升级需求，Bootloader 通过预留的通信接口接收新固件数据，并将其写入 Flash 的 User Application 区域。 固件验证：写入完成后，Bootloader 进行固件验证，确保数据完整性和正确性。 跳转执行：验证通过后，Bootloader 跳转到 User Application 区域的新固件执行。 关键步骤 Flash 存储器管理：包括擦除扇区、写入数据和校验数据等操作，这些操作通常以块或扇区为单位进行。 数据传输与接收：通过串口、USB 等通信接口接收新固件数据，并存储在 RAM 中，待验证无误后写入 Flash。 安全性与完整性校验：通过加密、签名和校验和等技术确保数据在传输和存储过程中的安全性和完整性。 在 STM32 上实现 IAP 程序STM32 启动流程STM32 在上电或复位后，首先会从内部的 Flash 存储器的起始地址（一般为 0x08000000）读取堆栈指针SP的值，然后加载复位向量，即跳转到复位处理函数。复位处理函数会进行一系列的系统初始化操作，包括时钟系统初始化、中断向量表的设置等。完成这些初始化后，会跳转到用户代码的入口点（通常是 main 函数）开始执行用户应用程序。在 IAP 实现中，了解这个启动流程对于正确划分 Bootloader 和 User Application 区域以及实现跳转执行等操作至关重要。 硬件准备以 STM32F103C8T6 为例，该单片机内置 64KB Flash 和 20KB SRAM。在进行 IAP 设计时，需要合理划分 Bootloader 和 User Application 的区域大小；这里我把 Flash 平均分为两部分，Bootloader 占 32KB，User Application 也占 32KB。 软件实现Bootloader 初始化硬件：对串口、时钟等相关硬件进行初始化设置，确保能正常进行数据通信与后续操作。例如，设置串口的波特率等参数，使能串口接收中断以便及时接收新固件数据。 检查升级指令：持续监听特定的升级指令，如通过串口接收特定的命令字符或数据包头信息来判断是否需要进行固件升级。 接收新固件数据：当检测到升级指令后，通过串口等通信接口按约定的协议接收新固件数据，并将其存储在 RAM 中。需要注意数据接收的完整性和顺序性，可采用数据帧编号、校验和等方式来保证。 写入 Flash：在接收到完整的固件数据并验证无误后，将数据从 RAM 写入到 Flash 的 User Application 区域。写入时要严格按照 Flash 的编程规范操作，先擦除对应扇区（因为 Flash 只能写 0 不能直接写 1，写入前需擦除为 1），再将数据逐字节或逐字写入。同时要处理好 Flash 写入的时序和编程电压等要求，防止写入错误。 跳转至应用程序（User Application）#define APP_FLASH_ADDRESS (0x8008000)typedef void (*pFunction)(void);pFunction Jump_To_Application;uint32_t JumpAddress;void JumpToApp(void) /* 检查是否为有效的栈地址，然后跳转到用户应用程序 */ if (((*(__IO uint32_t*)APP_FLASH_ADDRESS) 0x2FFE0000 ) == 0x20000000) __disable_irq(); /* 跳转到用户应用程序 */ JumpAddress = *(__IO uint32_t*) (APP_FLASH_ADDRESS + 4); Jump_To_Application = (pFunction) JumpAddress; /* 初始化用户应用程序的栈指针 */ __set_MSP(*(__IO uint32_t*) APP_FLASH_ADDRESS); Jump_To_Application(); User Application 配置中断向量表偏移：由于加入了 Bootloader 程序，User Application 的中断向量表位置发生了偏移。需要通过相应的函数来设置中断向量表的偏移量，在 STM32 中可以使用 NVIC_SetVectorTable() 函数。示例代码如下 ：#define FLASH_BASAE 0x08000000#define VECT_TAB_OFFEST 0x8000int main(void) // 修改中断向量 SCB-VTOR = FLASH_BASAE | VECT_TAB_OFFEST; 固件升级流程 设备上电后，Bootloader 首先检查是否有升级指令。 如果有，则通过串口等通信接口接收新固件数据。接收过程中要进行数据校验，如计算校验和并与发送端的校验和对比，确保数据准确无误。 接收完成后，进行固件验证，可采用加密算法验证数据的完整性和合法性，防止恶意固件更新。 验证无误后，跳转到新固件执行。在跳转前要确保系统处于稳定状态，关闭不必要的中断和外设，然后按照 STM32 的跳转指令规范准确地跳转到新固件的入口地址。 结束语这次关于嵌入式系统中 IAP 的分享就到此结束啦！希望通过这篇文章，大家对 IAP 有了较为全面且深入的认识。从它的基本概念到工作原理，从应用案例的展示到在 STM32 上的详细实现步骤，每一个环节都如同拼图的碎片，拼凑出了 IAP 技术的完整画卷。在实际应用中，大家可以依据自身项目需求，灵活运用 IAP 技术，为嵌入式设备打造更强大、更具适应性的固件更新方案。如果在实践过程中遇到任何问题，欢迎随时回顾本文或者查阅更多相关资料深入探索。感谢大家的阅读与关注，期待下一次与大家继续在嵌入式知识的海洋里畅游，共同挖掘更多有趣且实用的技术奥秘！","tags":["STM32","嵌入式"],"categories":["STM32"]},{"title":"想法","path":"/2024/12/12/b465bfd7c1b3/","content":"新年快乐呀，告别了略带遗憾的2024，来到了充满希望的2025，希望各位小伙伴们都学有所成，事业蒸蒸日上。 在2024我已经立下了一个挑战，就是在2025年保持一整年，每天上传代码等到github仓库上，使热力图全绿，这被我称为“全绿计划”，接下来一整年就努力坚持这个计划，我预计每周汇报一次学习成果，以及项目进度，然后总的记录下来，作为我成长路上的一个见证，同时也锻炼了我的写作水平。 对于2024，我想我应该还不够努力，我想在2025更加努力，我的2024关键词自我总结应该是嵌入式,电赛,C语言吧。 2025.1.2，明天就要出发去嵌入式比赛了，大概三天没有空，需要断更 今天是2025.1.6，说来好笑，明明说全绿计划，结果在新年第三天就开始断了，其实也不然，毕竟很多时候忙起来无法抽身是很常见事情呢，不过我尽量还是保持每日更新吧。 2025.3.14全绿计划崩盘了，个人没有毅力，不过最近尝试作了21年电赛J题，还是挺有难度的，特别是误差要控制在1%。","tags":["随笔","心情"]},{"title":"STM32代码配置模板","path":"/2024/01/26/3fd3faff9761/","content":"STM32代码配置模板快捷导航GPIO配置串口配置串口中断接收EXTI中断外设的GPIO配置 GPIO配置// 开启时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOX, ENABLE);// GPIO结构体配置GPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // GPIO 模式GPIO_InitStructure.GPIO_Pin = GPIO_Pin_X; // GPIO 引脚GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // GPIO 速度// 初始化GPIOGPIO_Init(GPIOX, GPIO_InitStructure);// 设置初始电平GPIO_SetBits(GPIOX, GPIO_Pin_X);// GPIO_ResetBits(GPIOX, GPIO_Pin_X); 串口配置// 开启时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOX, ENABLE);RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTXX, ENABLE);// GPIO结构体配置GPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // GPIO 模式GPIO_InitStructure.GPIO_Pin = GPIO_Pin_X; // GPIO 引脚GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // GPIO 速度GPIO_Init(GPIOX, GPIO_InitStructure);GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; // GPIO 模式GPIO_InitStructure.GPIO_Pin = GPIO_Pin_X; // GPIO 引脚GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // GPIO 速度GPIO_Init(GPIOX, GPIO_InitStructure);USART_InitTypeDef USART_InitStruct;USART_InitStruct.USART_BaudRate = 9600; // 波特率USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // 硬件流控制USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // 串口模式USART_InitStruct.USART_Parity = USART_Parity_No; // 奇偶校验位USART_InitStruct.USART_StopBits = USART_StopBits_1; // 停止位USART_InitStruct.USART_WordLength = USART_WordLength_8b; // 数据长度USART_Init(USARTX, USART_InitStruct);USART_ITConfig(USARTX, USART_IT_RXNE, ENABLE); // 串口中断配置NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // NVIC中断分组NVIC_InitTypeDef NVIC_InitStruct;NVIC_InitStruct.NVIC_IRQChannel = USART3_IRQn; // 中断通道NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; // 中断使能NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1; // 抢占优先级NVIC_InitStruct.NVIC_IRQChannelSubPriority = 1; // 响应优先级NVIC_Init(NVIC_InitStruct);USART_Cmd(USARTX, ENABLE); // 串口使能 串口中断接收void USART3_IRQHandler(void) /// 判断串口接收标志位，是否接收完成 if(USART_GetFlagStatus(USART3, USART_FLAG_RXNE) == SET) uint8_t recevieData = USART_ReceiveData(USART3); // 串口收到的数据 /* ... */ USART_ClearITPendingBit(USART3, USART_IT_RXNE); // 清除中断接收的标志位 EXTI中断EXTI通道表 EXTI1_IRQn EXTI2_IRQn EXTI3_IRQn EXTI4_IRQn EXTI9_5_IRQn EXTI15_10_IRQn 重定义中断函数的函数名 EXTI0_IRQHandler EXTI1_IRQHandler EXTI2_IRQHandler EXTI3_IRQHandler EXTI4_IRQHandler EXTI9_5_IRQHandler EXTI15_10_IRQHandler 不能直接复制使用，需要修改一些东西 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOX,ENABLE);//开启时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);//开启时钟//EXTI和NVIC两个外设的时钟一直都是打开的//NVIC是内核的外设，是不需要开启时钟的GPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_X;GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入GPIO_Init(GPIOX, GPIO_InitStructure);//PB14号引脚的电平信号，就顺利通过了AFIO,进入到后级的EXTI电路了GPIO_EXTILineConfig(GPIO_PortSourceGPIOX,GPIO_PinSourceX);//初始化EXTIEXTI_InitTypeDef EXTI_InitStructure;EXTI_InitStructure.EXTI_Line=EXTI_LineX;//14行EXTI_InitStructure.EXTI_LineCmd=ENABLE;//开启EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;//中断模式EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;//下降沿触发EXTI_Init(EXTI_InitStructure);//配置NVIC//分组方式整个芯片就只能用一组//可以放到主函数的最开始//放到模块里需要保证每个模块一致//取值范围抢占优先级（0-3），响应优先级（0-3）NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);NVIC_InitTypeDef NVIC_InitStruct;//选择对应的中断通道NVIC_InitStruct.NVIC_IRQChannel=EXTIX_IRQn;NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;//设置抢占优先级（0-3）NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=1;//设置响应优先级（0-3）NVIC_InitStruct.NVIC_IRQChannelSubPriority=1;NVIC_Init(NVIC_InitStruct); 外设的GPIO配置这里摘录自STM32F10xxx参考手册.pdf 8.1.11 外设的GPIO配置 TIM1TIM8(高级定时器)配置TIM2345(通用定时器)配置USART(串口)配置SPI配置I2S配置 TIM1TIM8(高级定时器)配置 TIM1/TIM8引脚配置GPIO配置 TIM1/8_CHx输入捕获通道x浮空输入 输出比较通道x推挽复用输出 TIM1/8_CHxN互补输出通道x推挽复用输出 TIM1/8_BKIN刹车输入浮空输入 TIM1/8_ETR外部触发时钟输入浮空输入 TIM2345(通用定时器)配置 TIM2/3/4/5引脚配置GPIO配置 TIM2/3/4/5_CHx输入捕获通道x浮空输入 输出比较通道x推挽复用输出 TIM2/3/4/5_ETR外部触发时钟输入浮空输入 USART(串口)配置 USART引脚配置GPIO配置 USARTx_TX全双工模式推挽复用输出 半双工同步模式推挽复用输出 USARTx_RX全双工模式浮空输入或带上拉输入 半双工同步模式未用，可作为通用I/O USARTx_CK同步模式推挽复用输出 USARTx_RTS硬件流量控制推挽复用输出 USARTx_CTS硬件流量控制浮空输入或带上拉输入 SPI配置 SPI引脚配置GPIO配置 SPIx_SCK主模式推挽复用输出 从模式浮空输入 SPIx_MOSI全双工模式/主模式推挽复用输出 全双工模式/从模式浮空输入或带上拉输入 简单的双向数据线/主模式推挽复用输出 简单的双向数据线/从模式未用，可作为通用I/O SPIx_MISO全双工模式/主模式浮空输入或带上拉输入 全双工模式/从模式推挽复用输出 简单的双向数据线/主模式未用，可作为通用I/O 简单的双向数据线/从模式推挽复用输出 SPIx_NSS硬件主/从模式推浮空输入或带上拉输入或带下拉输入 硬件主模式/NSS输出使能推挽复用输出 软件模式未用，可作为通用I/O I2S配置 I2S引脚配置GPIO配置 I2Sx_WS主模式推挽复用输出 从模式浮空输入 I2Sx_CK主模式推挽复用输出 从模式浮空输入 I2Sx_SD发送器推挽复用输出 接收器浮空输入或带上拉输入或带下拉输入 I2Sx_MCK主模式推挽复用输出 从模式未用，可作为通用I/O","tags":["STM32"],"categories":["STM32"]},{"title":"C语言注释规范","path":"/2023/10/13/a496743ab17d/","content":"C语言代码注释规范函数注释原则函数头部应进行注释，列出：函数的目的功能、输入参数、输出参数、返回值、调用关系（函数、表）等 /********************************************************* Function name ：insert_hhistory* Description : Insert to bd_host_history* Parameter ：* @ipsql SQL statement * @host_level Risk level * @total The total number of risk * @t_id task id* @t_uuid task uuid* @ipaddr target ipaddr * @end_time task end time* Return ：0 --success , other -- fail**********************************************************/int insert_hhistory(char* ipsql,risk host_level,int total,int t_id,char* t_uuid,char* ipaddr,long int end_time) /* * 如果程序过于复杂，这里可以写明，具体算法和思路。 */ 结构体、全局变量的注释int num; /*全局变量的作用*//*结构体的功能*/typedef struct int h; /*High risk*/ int l; /*Low risk*/ int m; /*Middle risk*/ int i; /*Information risk*/risk; 文件头部注释/********************************************************************************* @File name: biu.c* @Author: fanxing* @Version: 1.1* @Date: 2021-3-19* @Description: The function interface。********************************************************************************/ 宏定义/*! CTIMER 最大占空比 可自行修改 */#define CMTER_PWM_MAX 10000 变量注释/// 简述/** 详细描述. */","tags":["C语言"]},{"title":"Git | commit 规范","path":"/2023/10/02/e21da8549493/","content":"Git | commit 规范约定式提交通常要求提交内容包含五个部分 type 类型，用于传达提交的意图 # 主要Typefeat: 增加新功能fix: 修复Bug# 特殊Typedocs: 只改动文档相关内容styles: 不影响代码含义的改动，例如去掉空格，改变所经，增加分号build: 构造工具或外部依赖的改动，例如，webpack，npmrefactor: 代码重构时使用revert: 直行 git revert 打印的 message# 暂不使用Typetest: 增加测试或修改现有测试perf 提高性能的改动ci: 变更 CI 系统配置的更新chore: 不修改 src 或 test 的其余修改，例如构建过程或辅助工具的变动"},{"title":"Termux配置NeoVim保姆级教程","path":"/2022/09/25/7e590ba7e0f4/","content":"教你怎么用 Termux 配置一个优秀的 VimIDE 开始本人是一个专注移动端开发的人(其实是买不起电脑…)，移动端写代码确实没有那么方便，我还为此购买了一个键盘，有了这个键盘，扣代码真的超级爽的，自此我就一发不可收拾了。 但是，有了键盘，却没有一个优秀的编辑器，对于喜欢完美的我，这怎么能行，于是我打开了万能工具Termux。 Termux安装上了vim，可是vim没有配置，没有配置的vim就没有灵魂，本篇博客教你配置自己习惯的Vim Termux 的安装我安装的是Termux，这里我们去 Github 下载Termux，一般下载第一个即可，这里下载的比较慢，可以使用 第三方的 Github 的资源加速下载。 安装好后打开Termux Termux 的配置Termux 换源因为很多软件包的服务器都在国外，所以下载的速度非常缓慢，当然，我们国内也有相应的存放软件包的服务器，这里我们就换到国内的源，这样下载速度就会提升很多了。 这里我们更换中科大的源，把下面的命令粘贴过去回车就好，然后需要确定的时候一路按 y 就好。 sed -i s@^\\(deb.*stable main\\)$@#\\1 deb https://mirrors.ustc.edu.cn/termux/apt/termux-main stable main@g $PREFIX/etc/apt/sources.list ; apt update ; apt upgrade ; pkg up NeoVim 的安装这就很简单了，我们只需要在命令行粘贴一下代码就好了 # 安装pkg install neovim -y# 检验 Neovim 是否安装成功nvim -v 如果返回的信息如下所示，则说明 neovim 安装成功 安装成功后就可以进行下一步的配置 Neovim 了 Neovim的配置首先，我们需要创建两个文件夹 # 用于存放插件管理器mkdir ~/.congig/nvim/autoload/ -p# 用于存放下载的插件mkdir ~/.config/nvim/plugged/ -p# 创建 init.vim 配置文件touch ~/.config/nvim/init.vim # 安装 git pkg install git -y# 安装 nodejs pkg install nodejs -y 配置前的准备已经完成，下面开始安装插件管理器 这里我的选择是 vim-plug 作为插件管理器 # 下载 plug.vim 到 ~/.config/nvim/autoload/ 目录中# 如果遇到无法下载的情况可以使用科学上网curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim # 编辑 init.vim 文件nvim ~/.config/nvim/init.vim# --------------分界线---------------# 这里建议先学会 vim 的基础操作再来看# 进入编辑模式 显示行号set nu 黑暗模式set bg=dark 设置Tab宽度为4set shiftwidth=4set tabstop=4 关闭自动换行set nowrapcall plug#begin(~/.config/nvim/plugged) 编辑器主题Plug morhetz/gruvbox 状态栏主题Plug vim-airline/vim-airlinePlug vim-airline/vim-airline-themes 补全插件Plug neoclide/coc.nvim 目录树插件Plug preservim/nerdtree 括号补全插件Plug jiangmiao/auto-pairscall plug#end() 选择使用编辑器的主题autocmd vimenter * nested colorscheme gruvboxset laststatus=2 永远显示状态栏let g:airline_powerline_fonts = 1 支持 powerline 字体let g:airline#extensions#tabline#enabled = 1 显示窗口tab和buffer let g:airline_theme=moloai murmur配色不错if !exists(g:airline_symbols)let g:airline_symbols = endiflet g:airline_left_sep = ▶let g:airline_left_alt_sep = ❯let g:airline_right_sep = ◀let g:airline_right_alt_sep = ❮let g:airline_symbols.linenr = ¶let g:airline_symbols.branch = ⎇ 使用回车确认inoremap silentexpr CR coc#pum#visible() ? coc#pum#confirm() \\: \\C-gu\\CR\\c-r=coc#on_enter()\\CR 插件安装配置就先弄这些了，如后续有需要再自行添加，在上面内容都粘贴上去后，在按下ESC后输入:wq。然后再打开，直接输入:PlugInstall安装插件，这下，插件就安装完成了。 C语言开发环境配置接下来配置最为重要的一步 我们相让编辑器像VSCode那样好用，必定少不了lsp(language-server-protocol)的支持，我们所安装的coc.nvim便是支持lsp，接下来我们安装C语言的插件。 首先，我们需要安装C语言的环境，这里在命令行输入 pkg install clang -y 安装完成后，就在命令行输入nvim，发现此时有报错。 这个报错是一个Bug，我们完全可以通过一系列操作规避他。 首先，安装yarn npm install -g yarn # 进入coc.nvim所在目录cd .config/nvim/plugged/coc.nvim# 安装所需依赖yarn install# 构建yarn build 这些操作结束后，再在命令行输入nvim后就不会再有报错了，就可以安装我们所需的C语言插件了。 在nvim界面，输入:CocInstall coc-clangd，然后回车，安装成功后会显示。这下C语言插件就安装完成了，当然，其他语言的插件安装方法也类似。","tags":["Termux","Nvim"]},{"title":"Termux编译运行SpringBoot","path":"/2022/09/21/7f55d401c30d/","content":"使用Termux编译运行SpringBoot的教程 简介有不少的小伙伴因为各种原因没有电脑，到对开发的无限热爱，让他们在移动端也学会了编程，甚至在移动端写代码效率更高，于是，我就来帮助手机上写代码的小伙伴，拓展一下SpringBoot SpringBoot介绍SpringBoot是一个开发基于Spring框架的应用的快速开发框架，它也是SpringCloud构建微服务分布式系统的基础设施。 开始环境准备配置Maven仓库第一次编译结束语 环境准备 Java Maven(目前有这两个就够) Termux直接运行命令安装 pkg install openjdk-17 maven -y 配置Maven仓库默认的仓库地址不仅下载缓慢，甚至部分内容无法下载，所以，我们需要修改Maven仓库的源 首先，找到Maven的配置文件(Termux的默认配置文件相对路径为~..usroptmavenconfsettings.xml) 使用编辑器打开settings.xml 在图片对应位置插入下列内容到此，环境已经配置成功了！ 第一次编译前往spring initializr生成你的SpringBoot项目，把他复制到你的工作目录中 进入你所在的项目，如图所示 shellmvn package 运行命令，首次运行需要下载依赖，其下载时间可能过长，我测试耗时约2min，不同环境网络有可能差异，请耐心等待 编译完成，使用命令让其运作 java -jar target/demo-0.0.1-SNAPSHOT.jar 因为没有编写页面，所以默认访问没有页面，但出现以下页面，说明运行成功 结束语到此，本文章结束，本文略微讲述了使用Termux编译SpringBoot并且在手机上成功运行，极大的帮助了移动端开发的小伙伴。","tags":["Termux","Java","SpringBoot","Spring"]},{"title":"Hello World!","path":"/2022/09/20/c9b35e0eb932/","content":"Hexo博客终于搭建成功了，纪念一下！"},{"title":"关于","path":"/about/index.html","content":"这个人很懒，什么也没有留下。"}]