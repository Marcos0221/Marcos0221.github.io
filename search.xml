<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo代码框样式美化</title>
      <link href="/2025/01/06/2434ab2b60f4/"/>
      <url>/2025/01/06/2434ab2b60f4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我一直觉得很多的代码框的样式都有提升空间，不管是字体还是配色，我认为都有提升空间，毕竟，适合自己的才是最好的。但是为了满足实现自定义的效果我可是费足了心思，我查阅了非常多的官方文档与主题文档，最后才得来修改的方法，真是不易啊。</p><h2 id="着手实现"><a href="#着手实现" class="headerlink" title="着手实现"></a>着手实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LinuxC网络编程</title>
      <link href="/2025/01/05/7bf8e9a99bdb/"/>
      <url>/2025/01/05/7bf8e9a99bdb/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="&lt;sys&#x2F;socket.h&gt;"></a>&lt;sys&#x2F;socket.h&gt;</h1><p><strong>1</strong>. <code>socket</code></p><ul><li>创建一个新的套接字</li><li>函数原型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure></li><li><strong>参数</strong>:<ul><li>domain：指定协议族，常见的有 AF_INET（IPv4）、AF_INET6（IPv6）、AF_UNIX（本地套接字）等。</li><li>type：指定套接字类型，如 SOCK_STREAM（面向连接的流套接字，常用于 TCP）、SOCK_DGRAM（无连接的数据包套接字，常用于 UDP）、SOCK_RAW（原始套接字）等。</li><li>protocol：通常设置为 0，让系统根据 domain 和 type 选择默认协议。对于特定协议，也可以指定具体的协议号。</li></ul></li><li><strong>返回值</strong>：成功时返回一个非负整数表示套接字描述符，失败时返回 -1。</li></ul><p><strong>2</strong>. <code>bind</code></p><ul><li><strong>作用</strong>：将套接字绑定到一个特定的地址和端口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《嵌入式系统中的神奇魔法——IAP详解》</title>
      <link href="/2024/12/12/168241c6184c/"/>
      <url>/2024/12/12/168241c6184c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大家好，我是一名专注于嵌入式领域的知识分享者，在嵌入式系统开发与研究的道路上已经走过了不少年头，积累了丰富的实践经验与理论知识。在当今快速发展的科技时代，嵌入式设备无处不在，从我们日常使用的智能手机、智能家居设备，到工业控制中的复杂系统，乃至汽车的电子控制单元等。而这些设备的软件功能需要不断地优化、升级以适应新的需求、修复潜在漏洞以及提升性能。</p><p>在这样的背景下，IAP（In Application Programming，在应用中编程）技术应运而生并扮演着极为关键的角色。它就像是一把神奇的钥匙，开启了嵌入式设备固件更新的便捷之门，无需繁琐的拆卸或专业设备辅助，就能让设备在运行过程中通过预留的通信接口轻松完成固件的更新升级。这种技术极大地提高了设备的可维护性和灵活性，特别是在智能家居、汽车电子、物联网设备等需要频繁更新固件的场景中，IAP 已然成为了保障设备持续稳定高效运行以及功能不断拓展的核心技术力量，让嵌入式设备能够与时俱进，更好地服务于我们的生活与生产。接下来，就让我们深入探究 IAP 的奥秘。</p></blockquote><h2 id="什么是-IAP"><a href="#什么是-IAP" class="headerlink" title="什么是 IAP"></a>什么是 IAP</h2><p>IAP（In Application Programming，在应用中编程）是一种嵌入式系统中常用的固件更新技术。它允许用户程序在运行过程中，通过预留的通信接口对设备的固件进行更新升级。这种技术极大地提高了设备的可维护性和灵活性，特别是在智能家居、汽车电子、物联网设备等需要频繁更新固件的场景中尤为重要。</p><h2 id="IAP-的工作原理"><a href="#IAP-的工作原理" class="headerlink" title="IAP 的工作原理"></a>IAP 的工作原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>IAP 技术通过将 Flash 存储器划分为两个主要区域来实现固件更新。</li><li>Bootloader 区域：包含引导加载程序，负责初始化硬件、设置内存映射，并在需要时加载和更新用户应用程序（User Application）。Bootloader 出厂后通常固定不变，只有在特定条件下（如接收到升级指令）才执行更新操作。</li><li>User Application 区域：存放用户的应用程序代码，这部分代码在需要时可以通过 Bootloader 进行更新。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>设备启动：设备上电后，首先执行 Bootloader 程序。Bootloader 检查是否有升级指令或新固件数据待处理。</li><li>固件更新检查：如果检测到有升级需求，Bootloader 通过预留的通信接口接收新固件数据，并将其写入 Flash 的 User Application 区域。</li><li>固件验证：写入完成后，Bootloader 进行固件验证，确保数据完整性和正确性。</li><li>跳转执行：验证通过后，Bootloader 跳转到 User Application 区域的新固件执行。</li></ol><h3 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h3><ul><li>Flash 存储器管理：包括擦除扇区、写入数据和校验数据等操作，这些操作通常以块或扇区为单位进行。</li><li>数据传输与接收：通过串口、USB 等通信接口接收新固件数据，并存储在 RAM 中，待验证无误后写入 Flash。</li><li>安全性与完整性校验：通过加密、签名和校验和等技术确保数据在传输和存储过程中的安全性和完整性。</li></ul><h2 id="在-STM32-上实现-IAP-程序"><a href="#在-STM32-上实现-IAP-程序" class="headerlink" title="在 STM32 上实现 IAP 程序"></a>在 STM32 上实现 IAP 程序</h2><h3 id="STM32-启动流程"><a href="#STM32-启动流程" class="headerlink" title="STM32 启动流程"></a>STM32 启动流程</h3><p>STM32 在上电或复位后，首先会从内部的 Flash 存储器的起始地址（一般为 0x08000000）读取堆栈指针<strong>SP</strong>的值，然后<strong>加载复位向量</strong>，即<strong>跳转到复位处理函数</strong>。复位处理函数会进行一系列的系统初始化操作，包括时钟系统初始化、中断向量表的设置等。完成这些初始化后，会<strong>跳转到用户代码的入口点</strong>（通常是 main 函数）开始执行用户应用程序。在 IAP 实现中，了解这个启动流程对于正确划分 Bootloader 和 User Application 区域以及实现跳转执行等操作至关重要。</p><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>以 STM32F103C8T6 为例，该单片机内置 64KB Flash 和 20KB SRAM。在进行 IAP 设计时，需要合理划分 Bootloader 和 User Application 的区域大小；这里我把 Flash 平均分为两部分，Bootloader 占 32KB，User Application 也占 32KB。</p><h3 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h3><h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><ol><li>初始化硬件：对串口、时钟等相关硬件进行初始化设置，确保能正常进行数据通信与后续操作。例如，设置串口的波特率等参数，使能串口接收中断以便及时接收新固件数据。</li><li>检查升级指令：持续监听特定的升级指令，如通过串口接收特定的命令字符或数据包头信息来判断是否需要进行固件升级。</li><li>接收新固件数据：当检测到升级指令后，通过串口等通信接口按约定的协议接收新固件数据，并将其存储在 RAM 中。<strong>需要注意</strong>数据接收的完整性和顺序性，可采用数据帧编号、校验和等方式来保证。</li><li>写入 Flash：在接收到完整的固件数据并验证无误后，将数据从 RAM 写入到 Flash 的 User Application 区域。写入时要严格按照 Flash 的编程规范操作，先擦除对应扇区（因为 Flash 只能写 0 不能直接写 1，写入前需擦除为 1），再将数据逐字节或逐字写入。同时要处理好 Flash 写入的时序和编程电压等要求，防止写入错误。</li><li>跳转至应用程序（User Application）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> APP_FLASH_ADDRESS (0x8008000)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="title function_">void</span> <span class="params">(*pFunction)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">pFunction Jump_To_Application;</span><br><span class="line"><span class="type">uint32_t</span> JumpAddress;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">JumpToApp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 检查是否为有效的栈地址，然后跳转到用户应用程序 */</span></span><br><span class="line">    <span class="keyword">if</span> (((*(__IO <span class="type">uint32_t</span>*)APP_FLASH_ADDRESS) &amp; <span class="number">0x2FFE0000</span> ) == <span class="number">0x20000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __disable_irq();</span><br><span class="line">       <span class="comment">/* 跳转到用户应用程序 */</span></span><br><span class="line">       JumpAddress = *(__IO <span class="type">uint32_t</span>*) (APP_FLASH_ADDRESS + <span class="number">4</span>);</span><br><span class="line">       Jump_To_Application = (pFunction) JumpAddress;</span><br><span class="line">       <span class="comment">/* 初始化用户应用程序的栈指针 */</span></span><br><span class="line">       __set_MSP(*(__IO <span class="type">uint32_t</span>*) APP_FLASH_ADDRESS);</span><br><span class="line">       Jump_To_Application();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="User-Application"><a href="#User-Application" class="headerlink" title="User Application"></a>User Application</h4><ol><li>配置中断向量表偏移：由于加入了 Bootloader 程序，User Application 的中断向量表位置发生了偏移。需要通过相应的函数来设置中断向量表的偏移量，在 STM32 中可以使用 <code>NVIC_SetVectorTable()</code> 函数。示例代码如下 ：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_BASAE 0x08000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECT_TAB_OFFEST 0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 修改中断向量</span></span><br><span class="line">    SCB-&gt;VTOR = FLASH_BASAE | VECT_TAB_OFFEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- 1. 功能实现：专注于实现设备的具体业务功能，如传感器数据采集、数据处理与传输等。触发机制：预留触发 Bootloader 进行固件升级的机制，比如通过特定的串口命令、按键组合或者网络指令等。在接收到升级触发信号后，要能正确地跳转到 Bootloader 程序入口执行升级流程。同时，在正常运行过程中要避免误触发升级机制。2. Flash 分区：在链接脚本中明确划分 Bootloader 和 User Application 的 Flash 区域大小。确保两个区域不重叠，并预留足够的空间用于固件更新。例如，可将 Bootloader 区域设置为较小的固定大小，如 32KB，将剩余的 Flash 空间分配给 User Application，并考虑到未来固件升级可能增加的大小预留一定的余量。 --><h4 id="固件升级流程"><a href="#固件升级流程" class="headerlink" title="固件升级流程"></a>固件升级流程</h4><ol><li>设备上电后，Bootloader 首先检查是否有升级指令。</li><li>如果有，则通过串口等通信接口接收新固件数据。接收过程中要进行数据校验，如计算校验和并与发送端的校验和对比，确保数据准确无误。</li><li>接收完成后，进行固件验证，可采用加密算法验证数据的完整性和合法性，防止恶意固件更新。</li><li>验证无误后，跳转到新固件执行。在跳转前要确保系统处于稳定状态，关闭不必要的中断和外设，然后按照 STM32 的跳转指令规范准确地跳转到新固件的入口地址。</li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这次关于嵌入式系统中 IAP 的分享就到此结束啦！希望通过这篇文章，大家对 IAP 有了较为全面且深入的认识。从它的基本概念到工作原理，从应用案例的展示到在 STM32 上的详细实现步骤，每一个环节都如同拼图的碎片，拼凑出了 IAP 技术的完整画卷。在实际应用中，大家可以依据自身项目需求，灵活运用 IAP 技术，为嵌入式设备打造更强大、更具适应性的固件更新方案。如果在实践过程中遇到任何问题，欢迎随时回顾本文或者查阅更多相关资料深入探索。感谢大家的阅读与关注，期待下一次与大家继续在嵌入式知识的海洋里畅游，共同挖掘更多有趣且实用的技术奥秘！</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想法</title>
      <link href="/2024/12/12/b465bfd7c1b3/"/>
      <url>/2024/12/12/b465bfd7c1b3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>新年快乐呀，告别了略带遗憾的2024，来到了充满希望的2025，希望各位小伙伴们都学有所成，事业蒸蒸日上。</p></blockquote><p>在2024我已经立下了一个挑战，就是在2025年保持一整年，每天上传代码等到github仓库上，使热力图全绿，这被我称为“全绿计划”，接下来一整年就努力坚持这个计划，我预计每周汇报一次学习成果，以及项目进度，然后总的记录下来，作为我成长路上的一个见证，同时也锻炼了我的写作水平。</p><p>对于2024，我想我应该还不够努力，我想在2025更加努力，我的2024关键词自我总结应该是<code>嵌入式</code>,<code>电赛</code>,<code>C语言</code>吧。</p><p>2025.1.2，明天就要出发去嵌入式比赛了，大概三天没有空，需要断更</p><p>今天是2025.1.6，说来好笑，明明说全绿计划，结果在新年第三天就开始断了，其实也不然，毕竟很多时候忙起来无法抽身是很常见的谋生哦尽量还是保持每日更新吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓开发踩坑记录</title>
      <link href="/2024/12/12/6a7c5a8b24c7/"/>
      <url>/2024/12/12/6a7c5a8b24c7/</url>
      
        <content type="html"><![CDATA[<h2 id="通过包名启动app"><a href="#通过包名启动app" class="headerlink" title="通过包名启动app"></a>通过包名启动app</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**      </span></span><br><span class="line"><span class="comment">  * 通过包名启动应用</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> context            </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> packageName 欲启动应用包名</span></span><br><span class="line"><span class="comment">  */</span>                          </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openApp</span><span class="params">(context: <span class="type">Context</span>, packageName:<span class="type">String</span>)</span></span>&#123;                                           </span><br><span class="line">    <span class="keyword">val</span> intent = context.packageManager.getLaunchIntentForPackage(packageName)               </span><br><span class="line">    intent?.flags = Intent.FLAG_ACTIVITY_NEW_TASK ; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</span><br><span class="line">    context.startActivity(intent)                                                            </span><br><span class="line">&#125;                                                                                            </span><br></pre></td></tr></table></figure><p>试过了吗，是不是报错了，而且还是这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt to invoke virtual method &#x27;boolean android.content.Intent.migrateExtraStreamToClipData(android.content.Context)&#x27; on a null object reference</span><br></pre></td></tr></table></figure><blockquote><p>Android11及以上，谷歌权限收紧，调用<code>getLaunchIntentForPackage</code>时候，内部实现无法根据包名查询到对应activity名称了，所以获取的intent是null，也就是拉不起来了，声明后就可以查看了。</p></blockquote><p>所以我们需要在 <code>AndroidManifest.xml</code> 中配置声明包可见性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">queries</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">android:name</span>=<span class="string">&quot;com.marcos.xxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">queries</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再次尝试运行，是不是可以正常打开应用啦</p><p>如果觉得这样很麻烦的话，那么可以这样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.QUERY_ALL_PACKAGES&quot;</span> <span class="attr">tools:ignore</span>=<span class="string">&quot;QueryAllPackagesPermission&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样就不用重复配置了</p><p>参考文章：<a href="https://juejin.cn/post/7101284415300435982">Android 11以上如何通过包名拉起App</a></p><h2 id="状态栏顶起布局"><a href="#状态栏顶起布局" class="headerlink" title="状态栏顶起布局"></a>状态栏顶起布局</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在xml布局文件中的根布局添加，布局就不会被顶起了</span><br><span class="line">android:fitsSystemWindows=&quot;true&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM定时器编码器模式学习笔记</title>
      <link href="/2024/06/19/54ca602dd337/"/>
      <url>/2024/06/19/54ca602dd337/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32代码配置模板</title>
      <link href="/2024/01/26/3fd3faff9761/"/>
      <url>/2024/01/26/3fd3faff9761/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32代码配置模板"><a href="#STM32代码配置模板" class="headerlink" title="STM32代码配置模板"></a>STM32代码配置模板</h1><h2 id="快捷导航"><a href="#快捷导航" class="headerlink" title="快捷导航"></a>快捷导航</h2><p><a href="#t01">GPIO配置</a><br><a href="#t02">串口配置</a><br><a href="#t03">串口中断接收</a><br><a href="#t04">EXTI中断</a><br><a href="#t05">外设的GPIO配置</a></p><p><span id="t01"></span></p><h2 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOX, ENABLE);</span><br><span class="line"><span class="comment">// GPIO结构体配置</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;        <span class="comment">// GPIO 模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_X;              <span class="comment">// GPIO 引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       <span class="comment">// GPIO 速度</span></span><br><span class="line"><span class="comment">// 初始化GPIO</span></span><br><span class="line">GPIO_Init(GPIOX, &amp;GPIO_InitStructure);</span><br><span class="line"><span class="comment">// 设置初始电平</span></span><br><span class="line">GPIO_SetBits(GPIOX, GPIO_Pin_X);</span><br><span class="line"><span class="comment">// GPIO_ResetBits(GPIOX, GPIO_Pin_X);</span></span><br></pre></td></tr></table></figure><p><span id="t02"></span></p><h2 id="串口配置"><a href="#串口配置" class="headerlink" title="串口配置"></a>串口配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOX, ENABLE);</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTXX, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO结构体配置</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;         <span class="comment">// GPIO 模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_X;              <span class="comment">// GPIO 引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       <span class="comment">// GPIO 速度</span></span><br><span class="line">GPIO_Init(GPIOX, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;   <span class="comment">// GPIO 模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_X;              <span class="comment">// GPIO 引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       <span class="comment">// GPIO 速度</span></span><br><span class="line">GPIO_Init(GPIOX, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_InitTypeDef USART_InitStruct;</span><br><span class="line">USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;     <span class="comment">// 波特率</span></span><br><span class="line">USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;        <span class="comment">// 硬件流控制</span></span><br><span class="line">USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;        <span class="comment">// 串口模式</span></span><br><span class="line">USART_InitStruct.USART_Parity = USART_Parity_No;        <span class="comment">// 奇偶校验位</span></span><br><span class="line">USART_InitStruct.USART_StopBits = USART_StopBits_1;     <span class="comment">// 停止位</span></span><br><span class="line">USART_InitStruct.USART_WordLength = USART_WordLength_8b;        <span class="comment">// 数据长度</span></span><br><span class="line">USART_Init(USARTX, &amp;USART_InitStruct);</span><br><span class="line"></span><br><span class="line">USART_ITConfig(USARTX, USART_IT_RXNE, ENABLE);      <span class="comment">// 串口中断配置</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);     <span class="comment">// NVIC中断分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = USART3_IRQn;      <span class="comment">// 中断通道</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;        <span class="comment">// 中断使能</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;      <span class="comment">// 抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;     <span class="comment">// 响应优先级</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USARTX, ENABLE);      <span class="comment">// 串口使能</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><span id="t03"></span></p><h2 id="串口中断接收"><a href="#串口中断接收" class="headerlink" title="串口中断接收"></a>串口中断接收</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 判断串口接收标志位，是否接收完成</span></span><br><span class="line">    <span class="keyword">if</span>(USART_GetFlagStatus(USART3, USART_FLAG_RXNE) == SET)&#123;</span><br><span class="line">        <span class="type">uint8_t</span> recevieData = USART_ReceiveData(USART3);    <span class="comment">// 串口收到的数据</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        USART_ClearITPendingBit(USART3, USART_IT_RXNE);     <span class="comment">// 清除中断接收的标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="t04"></span></p><h2 id="EXTI中断"><a href="#EXTI中断" class="headerlink" title="EXTI中断"></a>EXTI中断</h2><p><strong>EXTI通道表</strong></p><ul><li>EXTI1_IRQn </li><li>EXTI2_IRQn</li><li>EXTI3_IRQn</li><li>EXTI4_IRQn</li><li>EXTI9_5_IRQn</li><li>EXTI15_10_IRQn</li></ul><p><strong>重定义中断函数的函数名</strong></p><ul><li>EXTI0_IRQHandler</li><li>EXTI1_IRQHandler</li><li>EXTI2_IRQHandler</li><li>EXTI3_IRQHandler</li><li>EXTI4_IRQHandler</li><li>EXTI9_5_IRQHandler</li><li>EXTI15_10_IRQHandler</li></ul><p><strong>不能直接复制使用，需要修改一些东西</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOX,ENABLE);<span class="comment">//开启时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//开启时钟</span></span><br><span class="line"><span class="comment">//EXTI和NVIC两个外设的时钟一直都是打开的</span></span><br><span class="line"><span class="comment">//NVIC是内核的外设，是不需要开启时钟的</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_X;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<span class="comment">//上拉输入</span></span><br><span class="line">GPIO_Init(GPIOX, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PB14号引脚的电平信号，就顺利通过了AFIO,进入到后级的EXTI电路了</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOX,GPIO_PinSourceX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化EXTI</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_LineX;<span class="comment">//14行</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd=ENABLE;<span class="comment">//开启</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;<span class="comment">//中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;<span class="comment">//下降沿触发</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置NVIC</span></span><br><span class="line"><span class="comment">//分组方式整个芯片就只能用一组</span></span><br><span class="line"><span class="comment">//可以放到主函数的最开始</span></span><br><span class="line"><span class="comment">//放到模块里需要保证每个模块一致</span></span><br><span class="line"><span class="comment">//取值范围抢占优先级（0-3），响应优先级（0-3）</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line"><span class="comment">//选择对应的中断通道</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel=EXTIX_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line"><span class="comment">//设置抢占优先级（0-3）</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//设置响应优先级（0-3）</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br></pre></td></tr></table></figure><p><span id="t05"></span></p><h2 id="外设的GPIO配置"><a href="#外设的GPIO配置" class="headerlink" title="外设的GPIO配置"></a>外设的GPIO配置</h2><p><strong>这里摘录自STM32F10xxx参考手册.pdf 8.1.11 外设的GPIO配置</strong></p><p><a href="#w01">TIM1&#x2F;TIM8(高级定时器)配置</a><br><a href="#w02">TIM2&#x2F;3&#x2F;4&#x2F;5(通用定时器)配置</a><br><a href="#w03">USART(串口)配置</a><br><a href="#w04">SPI配置</a><br><a href="#w05">I2S配置</a></p><p><span id="w01"></span></p><h3 id="TIM1-TIM8-高级定时器-配置"><a href="#TIM1-TIM8-高级定时器-配置" class="headerlink" title="TIM1&#x2F;TIM8(高级定时器)配置"></a>TIM1&#x2F;TIM8(高级定时器)配置</h3><table style="text-align:center;">    <thead>        <tr><td>TIM1/TIM8引脚</td><td>配置</td><td>GPIO配置</td></tr><tr>    </thead>        <td rowspan="2">TIM1/8_CHx</td><td>输入捕获通道x</td><td>浮空输入</td>    </tr>    <tr>        <td>输出比较通道x</td><td>推挽复用输出</td>    </tr>    <tr>        <td>TIM1/8_CHxN</td><td>互补输出通道x</td><td>推挽复用输出</td>    </tr>    <tr>        <td>TIM1/8_BKIN</td><td>刹车输入</td><td>浮空输入</td>    </tr>    <tr>        <td>TIM1/8_ETR</td><td>外部触发时钟输入</td><td>浮空输入</td>    </tr></table><p><span id="w02"></span></p><h3 id="TIM2-3-4-5-通用定时器-配置"><a href="#TIM2-3-4-5-通用定时器-配置" class="headerlink" title="TIM2&#x2F;3&#x2F;4&#x2F;5(通用定时器)配置"></a>TIM2&#x2F;3&#x2F;4&#x2F;5(通用定时器)配置</h3><table style="text-align:center;">    <thead>        <tr><td>TIM2/3/4/5引脚</td><td>配置</td><td>GPIO配置</td></tr>    </thead>    <tr>        <td rowspan="2">TIM2/3/4/5_CHx</td><td>输入捕获通道x</td><td>浮空输入</td>    </tr>    <tr>        <td>输出比较通道x</td><td>推挽复用输出</td>    </tr>    <tr>        <td>TIM2/3/4/5_ETR</td><td>外部触发时钟输入</td><td>浮空输入</td>    </tr></table><p><span id="w03"></span></p><h3 id="USART-串口-配置"><a href="#USART-串口-配置" class="headerlink" title="USART(串口)配置"></a>USART(串口)配置</h3><table style="text-align:center;">    <thead>        <tr><td>USART引脚</td><td>配置</td><td>GPIO配置</td></tr>    </thead>    <tr>        <td rowspan="2">USARTx_TX</td><td>全双工模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>半双工同步模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td rowspan="2">USARTx_RX</td><td>全双工模式</td><td>浮空输入或带上拉输入</td>    </tr>    <tr>        <td>半双工同步模式</td><td>未用，可作为通用I/O</td>    </tr>    <tr>        <td>USARTx_CK</td><td>同步模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>USARTx_RTS</td><td>硬件流量控制</td><td>推挽复用输出</td>    </tr>    <tr>        <td>USARTx_CTS</td><td>硬件流量控制</td><td>浮空输入或带上拉输入</td>    </tr></table><p><span id="w04"></span></p><h3 id="SPI配置"><a href="#SPI配置" class="headerlink" title="SPI配置"></a>SPI配置</h3><table style="text-align:center;">    <thead>        <tr><td>SPI引脚</td><td>配置</td><td>GPIO配置</td></tr>    </thead>    <tr>        <td rowspan="2">SPIx_SCK</td><td>主模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>从模式</td><td>浮空输入</td>    </tr>    <tr>        <td rowspan="4">SPIx_MOSI</td><td>全双工模式/主模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>全双工模式/从模式</td><td>浮空输入或带上拉输入</td>    </tr>    <tr>        <td>简单的双向数据线/主模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>简单的双向数据线/从模式</td><td>未用，可作为通用I/O</td>    </tr>    <tr>        <td rowspan="4">SPIx_MISO</td><td>全双工模式/主模式</td><td>浮空输入或带上拉输入</td>    </tr>    <tr>        <td>全双工模式/从模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>简单的双向数据线/主模式</td><td>未用，可作为通用I/O</td>    </tr>    <tr>        <td>简单的双向数据线/从模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td rowspan="3">SPIx_NSS</td><td>硬件主/从模式</td><td>推浮空输入或带上拉输入或带下拉输入</td>    </tr>    <tr>        <td>硬件主模式/NSS输出使能</td><td>推挽复用输出</td>    </tr>    <tr>        <td>软件模式</td><td>未用，可作为通用I/O</td>    </tr></table><p><span id="w05"></span></p><h3 id="I2S配置"><a href="#I2S配置" class="headerlink" title="I2S配置"></a>I2S配置</h3><table style="text-align:center;">    <thead>        <tr><td>I2S引脚</td><td>配置</td><td>GPIO配置</td></tr>    </thead>    <tr>        <td rowspan="2">I2Sx_WS</td><td>主模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>从模式</td><td>浮空输入</td>    </tr>    <tr>        <td rowspan="2">I2Sx_CK</td><td>主模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>从模式</td><td>浮空输入</td>    </tr>    <tr>        <td rowspan="2">I2Sx_SD</td><td>发送器</td><td>推挽复用输出</td>    </tr>    <tr>        <td>接收器</td><td>浮空输入或带上拉输入或带下拉输入</td>    </tr>    <tr>        <td rowspan="2">I2Sx_MCK</td><td>主模式</td><td>推挽复用输出</td>    </tr>    <tr>        <td>从模式</td><td>未用，可作为通用I/O</td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言注释规范</title>
      <link href="/2023/10/13/a496743ab17d/"/>
      <url>/2023/10/13/a496743ab17d/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言代码注释规范"><a href="#C语言代码注释规范" class="headerlink" title="C语言代码注释规范"></a>C语言代码注释规范</h1><h2 id="函数注释原则"><a href="#函数注释原则" class="headerlink" title="函数注释原则"></a>函数注释原则</h2><p>函数头部应进行注释，列出：函数的目的&#x2F;功能、输入参数、输出参数、返回值、调用关系（函数、表）等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">* Function name ：insert_hhistory</span></span><br><span class="line"><span class="comment">* Description        : Insert to bd_host_history</span></span><br><span class="line"><span class="comment">* Parameter         ：</span></span><br><span class="line"><span class="comment">* @ipsql            SQL statement </span></span><br><span class="line"><span class="comment">* @host_level        Risk level    </span></span><br><span class="line"><span class="comment">* @total            The total number of risk </span></span><br><span class="line"><span class="comment">* @t_id            task id</span></span><br><span class="line"><span class="comment">* @t_uuid            task uuid</span></span><br><span class="line"><span class="comment">* @ipaddr            target ipaddr    </span></span><br><span class="line"><span class="comment">* @end_time        task end time</span></span><br><span class="line"><span class="comment">* Return          ：0 --success  ,  other -- fail</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert_hhistory</span><span class="params">(<span class="type">char</span>* ipsql,risk host_level,<span class="type">int</span> total,<span class="type">int</span> t_id,<span class="type">char</span>* t_uuid,<span class="type">char</span>* ipaddr,<span class="type">long</span> <span class="type">int</span> end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *    如果程序过于复杂，这里可以写明，具体算法和思路。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结构体、全局变量的注释"><a href="#结构体、全局变量的注释" class="headerlink" title="结构体、全局变量的注释"></a>结构体、全局变量的注释</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num; <span class="comment">/*全局变量的作用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*结构体的功能*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> h; <span class="comment">/*High risk*/</span></span><br><span class="line">    <span class="type">int</span> l; <span class="comment">/*Low risk*/</span></span><br><span class="line">    <span class="type">int</span> m; <span class="comment">/*Middle risk*/</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">/*Information risk*/</span></span><br><span class="line">&#125;risk;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件头部注释"><a href="#文件头部注释" class="headerlink" title="文件头部注释"></a>文件头部注释</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* @File name: biu.c</span></span><br><span class="line"><span class="comment">* @Author: fanxing</span></span><br><span class="line"><span class="comment">* @Version: 1.1</span></span><br><span class="line"><span class="comment">* @Date: 2021-3-19</span></span><br><span class="line"><span class="comment">* @Description: The function interface。</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br></pre></td></tr></table></figure><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*! CTIMER 最大占空比 可自行修改 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  CMTER_PWM_MAX    10000</span></span><br></pre></td></tr></table></figure><h2 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 简述</span></span><br><span class="line"><span class="comment">/** 详细描述. */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git | commit 规范</title>
      <link href="/2023/10/02/e21da8549493/"/>
      <url>/2023/10/02/e21da8549493/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-commit-规范"><a href="#Git-commit-规范" class="headerlink" title="Git | commit 规范"></a>Git | commit 规范</h1><h2 id="约定式提交"><a href="#约定式提交" class="headerlink" title="约定式提交"></a>约定式提交</h2><p>通常要求提交内容包含五个部分</p><ul><li><strong>type</strong> 类型，用于传达提交的意图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 主要Type</span><br><span class="line">feat:           增加新功能</span><br><span class="line">fix:            修复Bug</span><br><span class="line"></span><br><span class="line"># 特殊Type</span><br><span class="line">docs:           只改动文档相关内容</span><br><span class="line">styles:         不影响代码含义的改动，例如去掉空格，改变所经，增加分号</span><br><span class="line">build:          构造工具或外部依赖的改动，例如，webpack，npm</span><br><span class="line">refactor:       代码重构时使用</span><br><span class="line">revert:         直行 git revert 打印的 message</span><br><span class="line"></span><br><span class="line"># 暂不使用Type</span><br><span class="line">test:           增加测试或修改现有测试</span><br><span class="line">perf            提高性能的改动</span><br><span class="line">ci:             变更 CI 系统配置的更新</span><br><span class="line">chore:          不修改 src 或 test 的其余修改，例如构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Termux配置NeoVim保姆级教程</title>
      <link href="/2022/09/25/7e590ba7e0f4/"/>
      <url>/2022/09/25/7e590ba7e0f4/</url>
      
        <content type="html"><![CDATA[<p>教你怎么用 Termux 配置一个优秀的 VimIDE</p><span id="more"></span><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>本人是一个专注移动端开发的人(其实是买不起电脑…)，移动端写代码确实没有那么方便，我还为此购买了一个键盘，有了这个键盘，扣代码真的超级爽的，自此我就一发不可收拾了。</p><p>但是，有了键盘，却没有一个优秀的编辑器，对于喜欢完美的我，这怎么能行，于是我打开了万能工具Termux。</p><p>Termux安装上了vim，可是vim没有配置，没有配置的vim就没有灵魂，本篇博客教你配置自己习惯的Vim</p><h3 id="Termux-的安装"><a href="#Termux-的安装" class="headerlink" title="Termux 的安装"></a>Termux 的安装</h3><p>我安装的是<code>Termux</code>，这里我们去 Github 下载<a href="https://github.com/termux/termux-app/releases/tag/v0.118.1">Termux</a>，<br>一般下载第一个即可，这里下载的比较慢，可以使用 第三方的 Github 的资源加速下载。</p><p><img src="https://pic1.imgdb.cn/item/677fd9c5d0e0a243d4f2cf42.png" alt="安装包列表"></p><p>安装好后打开<code>Termux</code></p><p><img src="https://pic1.imgdb.cn/item/677fd9c5d0e0a243d4f2cf41.png" alt="应用图标"></p><h3 id="Termux-的配置"><a href="#Termux-的配置" class="headerlink" title="Termux 的配置"></a>Termux 的配置</h3><h4 id="Termux-换源"><a href="#Termux-换源" class="headerlink" title="Termux 换源"></a>Termux 换源</h4><p>因为很多软件包的服务器都在国外，所以下载的速度非常缓慢，当然，我们国内也有相应的存放软件包的服务器，这里我们就换到国内的源，这样下载速度就会提升很多了。</p><p>这里我们更换中科大的源，把下面的命令粘贴过去回车就好，然后需要确定的时候一路按 y 就好。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s@^\(deb.*stable main\)$@#\1\ndeb https://mirrors.ustc.edu.cn/termux/apt/termux-main stable main@g&#x27; $PREFIX/etc/apt/sources.list ; apt update ; apt upgrade ; pkg up</span><br></pre></td></tr></table></figure><h3 id="NeoVim-的安装"><a href="#NeoVim-的安装" class="headerlink" title="NeoVim 的安装"></a>NeoVim 的安装</h3><p>这就很简单了，我们只需要在命令行粘贴一下代码就好了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pkg install neovim -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检验 Neovim 是否安装成功</span></span><br><span class="line">nvim -v</span><br></pre></td></tr></table></figure><p>如果返回的信息如下所示，则说明 neovim 安装成功</p><img src="https://pic.imgdb.cn/item/6512e7e5c458853aeffa0e2c.jpg" style="zoom: 67%;" /><p>安装成功后就可以进行下一步的配置 Neovim 了</p><h3 id="Neovim的配置"><a href="#Neovim的配置" class="headerlink" title="Neovim的配置"></a>Neovim的配置</h3><p>首先，我们需要创建两个文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于存放插件管理器</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/.congig/nvim/autoload/ -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存放下载的插件</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/.config/nvim/plugged/ -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 init.vim 配置文件</span></span><br><span class="line"><span class="built_in">touch</span> ~/.config/nvim/init.vim </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 git </span></span><br><span class="line">pkg install git -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 nodejs </span></span><br><span class="line">pkg install nodejs -y</span><br></pre></td></tr></table></figure><p>配置前的准备已经完成，下面开始安装插件管理器</p><p>这里我的选择是 vim-plug 作为插件管理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 plug.vim 到 ~/.config/nvim/autoload/ 目录中</span></span><br><span class="line"><span class="comment"># 如果遇到无法下载的情况可以使用科学上网</span></span><br><span class="line">curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑 init.vim 文件</span></span><br><span class="line">nvim ~/.config/nvim/init.vim</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------分界线---------------</span></span><br><span class="line"><span class="comment"># 这里建议先学会 vim 的基础操作再来看</span></span><br><span class="line"><span class="comment"># 进入编辑模式</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 显示行号</span></span><br><span class="line"><span class="string">set nu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 黑暗模式</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">bg</span>=dark</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 设置Tab宽度为4</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 关闭自动换行</span><br><span class="line"><span class="built_in">set</span> nowrap</span><br><span class="line"></span><br><span class="line">call plug#begin(<span class="string">&#x27;~/.config/nvim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 编辑器主题</span></span><br><span class="line"><span class="string">Plug &#x27;morhetz/gruvbox&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 状态栏主题</span><br><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline-themes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 补全插件</span></span><br><span class="line"><span class="string">Plug &#x27;neoclide/coc.nvim&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 目录树插件</span><br><span class="line">Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 括号补全插件</span></span><br><span class="line"><span class="string">Plug &#x27;jiangmiao/auto-pairs&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">call plug#end()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 选择使用编辑器的主题</span><br><span class="line">autocmd vimenter * nested colorscheme gruvbox</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> laststatus=2  <span class="string">&quot;永远显示状态栏</span></span><br><span class="line"><span class="string">let g:airline_powerline_fonts = 1  &quot;</span>支持 powerline 字体</span><br><span class="line"><span class="built_in">let</span> g:airline#extensions#tabline#enabled = 1 <span class="string">&quot; 显示窗口tab和buffer</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">let</span> g:airline_theme=<span class="string">&#x27;moloai&#x27;</span>  <span class="string">&quot; murmur配色不错</span></span><br><span class="line"><span class="string">if !exists(&#x27;g:airline_symbols&#x27;)</span></span><br><span class="line"><span class="string">let g:airline_symbols = &#123;&#125;</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string">let g:airline_left_sep = &#x27;▶&#x27;</span></span><br><span class="line"><span class="string">let g:airline_left_alt_sep = &#x27;❯&#x27;</span></span><br><span class="line"><span class="string">let g:airline_right_sep = &#x27;◀&#x27;</span></span><br><span class="line"><span class="string">let g:airline_right_alt_sep = &#x27;❮&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.linenr = &#x27;¶&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.branch = &#x27;⎇&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 使用回车确认</span><br><span class="line">inoremap &lt;silent&gt;&lt;<span class="built_in">expr</span>&gt; &lt;CR&gt; coc#pum#visible() ? coc#pum#confirm()</span><br><span class="line">                              \: <span class="string">&quot;\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;=coc#on_enter()\&lt;CR&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>插件安装配置就先弄这些了，如后续有需要再自行添加，在上面内容都粘贴上去后，在按下<code>ESC</code>后输入<code>:wq</code>。然后再打开，直接输入<code>:PlugInstall</code>安装插件，这下，插件就安装完成了。</p><h3 id="C语言开发环境配置"><a href="#C语言开发环境配置" class="headerlink" title="C语言开发环境配置"></a>C语言开发环境配置</h3><p>接下来配置最为重要的一步</p><p>我们相让编辑器像<code>VSCode</code>那样好用，必定少不了<code>lsp(language-server-protocol)</code>的支持，我们所安装的<code>coc.nvim</code>便是支持<code>lsp</code>，接下来我们安装<code>C语言</code>的插件。</p><p>首先，我们需要安装<code>C语言</code>的环境，这里在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install clang -y</span><br></pre></td></tr></table></figure><p>安装完成后，就在命令行输入<code>nvim</code>，发现此时有报错<br><img src="https://pic1.imgdb.cn/item/6780f4fed0e0a243d4f3128c.png" alt="报错图片">。</p><p>这个报错是一个Bug，我们完全可以通过一系列操作规避他。</p><p>首先，安装<code>yarn</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入coc.nvim所在目录</span></span><br><span class="line"><span class="built_in">cd</span> .config/nvim/plugged/coc.nvim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需依赖</span></span><br><span class="line">yarn install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure><p>这些操作结束后，再在命令行输入<code>nvim</code>后就不会再有报错了，就可以安装我们所需的<code>C语言</code>插件了。</p><p>在nvim界面，输入<code>:CocInstall coc-clangd</code>，然后回车，安装成功后会显示<br><img src="https://pic1.imgdb.cn/item/6780f82dd0e0a243d4f31385.png" alt="安装成功显示图片">。这下C语言插件就安装完成了，当然，其他语言的插件安装方法也类似。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Termux </tag>
            
            <tag> Nvim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Termux编译运行SpringBoot</title>
      <link href="/2022/09/21/7f55d401c30d/"/>
      <url>/2022/09/21/7f55d401c30d/</url>
      
        <content type="html"><![CDATA[<p>使用Termux编译运行SpringBoot的教程</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>有不少的小伙伴因为各种原因没有电脑，到对开发的无限热爱，让他们在移动端也学会了编程，甚至在移动端写代码效率更高，于是，我就来帮助手机上写代码的小伙伴，拓展一下SpringBoot</p><h2 id="SpringBoot介绍"><a href="#SpringBoot介绍" class="headerlink" title="SpringBoot介绍"></a>SpringBoot介绍</h2><p>SpringBoot是一个开发基于Spring框架的应用的快速开发框架，它也是SpringCloud构建微服务分布式系统的基础设施。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><a href="#t01">环境准备</a><br><a href="#t02">配置Maven仓库</a><br><a href="#t03">第一次编译</a><br><a href="#t04">结束语</a></p><p><span id="t01"></span></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>Java</li><li>Maven<br>(目前有这两个就够)</li></ul><p>Termux直接运行命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install openjdk-17 maven -y</span><br></pre></td></tr></table></figure><p><span id="t02"></span></p><h4 id="配置Maven仓库"><a href="#配置Maven仓库" class="headerlink" title="配置Maven仓库"></a>配置Maven仓库</h4><p>默认的仓库地址不仅下载缓慢，甚至部分内容无法下载，所以，我们需要修改Maven仓库的源</p><ol><li>首先，找到Maven的配置文件(Termux的默认配置文件相对路径为~&#x2F;..&#x2F;usr&#x2F;opt&#x2F;maven&#x2F;conf&#x2F;settings.xml)</li><li>使用编辑器打开settings.xml</li><li>在图片对应位置插入下列内容<br><img src="https://s1.328888.xyz/2022/09/21/2qPTK.jpg" alt="如图所示"><br>到此，环境已经配置成功了！</li></ol><p><span id="t03"></span></p><h3 id="第一次编译"><a href="#第一次编译" class="headerlink" title="第一次编译"></a>第一次编译</h3><p>前往<a href="https://start.spring.io/">spring initializr</a>生成你的SpringBoot项目，把他复制到你的工作目录中</p><p>进入你所在的项目，如图所示<br><img src="https://s1.328888.xyz/2022/09/21/2pAAK.jpg" alt="目录结构示意图"></p><figure class="highlight plaintext"><figcaption><span>shell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>运行命令，首次运行需要下载依赖，其下载时间可能过长，我测试耗时约2min，不同环境网络有可能差异，请耐心等待<br><img src="https://s1.328888.xyz/2022/09/21/2qJ7J.jpg" alt="安装结束示意图"></p><p>编译完成，使用命令让其运作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/demo-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/09/21/2qYQF.jpg" alt="运行示例"></p><p>因为没有编写页面，所以默认访问没有页面，但出现以下页面，说明运行成功<br><img src="https://s1.328888.xyz/2022/09/21/2XOCX.jpg" alt="运行结果"></p><p><span id="t04"><span></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>到此，本文章结束，本文略微讲述了使用Termux编译SpringBoot并且在手机上成功运行，极大的帮助了移动端开发的小伙伴。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Termux </tag>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2022/09/20/c9b35e0eb932/"/>
      <url>/2022/09/20/c9b35e0eb932/</url>
      
        <content type="html"><![CDATA[<p>Hexo博客终于搭建成功了，纪念一下！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
